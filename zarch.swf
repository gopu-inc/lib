#!/usr/bin/env swift

// ============================================================
//  ZARCH - SwiftFlow Package Manager v1.1
// ============================================================

import "http";
import "sys";
import "io";
import "json";
import "std"; // Nouveau module standard

var REGISTRY_URL = "https://zenv-hub.onrender.com";
var INSTALL_PATH = "/usr/local/bin"; // Path global

// ... (Fonctions log_info, log_error, etc. identiques √† avant) ...

func log_info(msg) { print("\033[36m[INFO] \033[0m", msg); }
func log_success(msg) { print("\033[32m[OK]   \033[0m", msg); }
func log_error(msg) { print("\033[31m[FAIL] \033[0m", msg); sys.exit(1); }

// ============================================================
//  GESTION DES BINAIRES (LINK)
// ============================================================

func cmd_link_bin() {
    // 1. Lire le zarch.json courant
    if (io.exists("zarch.json", "has_conf"); has_conf == "no") {
        log_error("Aucun fichier zarch.json trouv√©.");
        return;
    }
    
    io.read("zarch.json", "content");
    
    // 2. Chercher la configuration "bin" ou "link"
    // Format attendu: "bin": { "mycmd": "src/main.swf" }
    // Note: Notre parser JSON actuel est limit√©, on va supposer une cl√© simple "bin_entry"
    // et "bin_alias" pour ce prototype, ou parser "main"
    
    var entry = json.get(content, "main");
    var alias = json.get(content, "alias"); // Nouvelle cl√© dans zarch.json
    var name = json.get(content, "name");
    
    if (entry == null) {
        log_error("Pas de point d'entr√©e 'main' d√©fini dans zarch.json");
        return;
    }
    
    // Si pas d'alias, on utilise le nom du paquet
    if (alias == null) alias = name;
    
    // 3. Pr√©parer le fichier source
    // Ajouter le shebang si absent (via sys.exec sed ou echo)
    // Pour simplifier, on suppose que le d√©v l'a mis ou on chmod juste
    
    var abs_path_cmd = "pwd";
    sys.exec(abs_path_cmd); // Affiche le path, faudrait le capturer
    // Astuce: utiliser realpath sur l'entry
    
    var source_file = "./" + entry;
    
    // 4. Rendre ex√©cutable
    print("üîß  Permission d'ex√©cution sur : ", source_file);
    var cmd_chmod = "chmod +x " + source_file;
    sys.exec(cmd_chmod);
    
    // 5. Cr√©er le lien syst√®me
    // Attention: n√©cessite souvent sudo
    var target_link = INSTALL_PATH + "/" + alias;
    
    print("üîó  Cr√©ation du lien : ", target_link, " -> ", source_file);
    
    // On utilise `ln -sf $(pwd)/fichier /usr/local/bin/alias`
    // Note: pwd est n√©cessaire pour le lien absolu
    var cmd_link = "ln -sf $(pwd)/" + entry + " " + target_link;
    
    var res = sys.exec(cmd_link);
    
    if (res == 0) {
        log_success("Commande '" + alias + "' install√©e !");
        print("    Essayez de taper : " + alias);
    } else {
        log_error("Impossible de cr√©er le lien (Permission refus√©e ? Essayez sudo)");
    }
}

// ... (Fonctions install, init identiques √† avant) ...

// ============================================================
//  MAIN
// ============================================================

main() {
    var cmd = sys.argv(0);
    
    if (cmd == "link") {
        // zarch link (utilise le zarch.json courant)
        cmd_link_bin();
    }
    else if (cmd == "install") {
        var pkg = sys.argv(1);
        // ... code install ...
        print("Install TODO (copier code pr√©c√©dent)");
    }
    else {
        print("Usage: zarch [install|link|init]");
    }
}
