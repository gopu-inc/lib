#!/usr/bin/env swift

// ============================================================
//  ZARCH - SwiftFlow Package Manager v1.2
//  (c) 2026 Gopu Inc.
// ============================================================

import "http";
import "sys";
import "io";
import "json";
import "std";

// --- CONFIGURATION ---
var REGISTRY_URL = "https://zenv-hub.onrender.com";
var MODULES_DIR = "./zarch_modules";
var INSTALL_PATH = "/usr/local/bin";

// --- COULEURS ANSI ---
var C_RESET = "\033[0m";
var C_BOLD = "\033[1m";
var C_CYAN = "\033[36m";
var C_GREEN = "\033[32m";
var C_YELLOW = "\033[33m";
var C_RED = "\033[31m";

// ============================================================
//  FONCTIONS UTILITAIRES
// ============================================================

func log_info(msg) { print(C_CYAN, "[INFO] ", C_RESET, msg); }
func log_success(msg) { print(C_GREEN, "[OK]   ", C_RESET, msg); }
func log_warn(msg) { print(C_YELLOW, "[WARN] ", C_RESET, msg); }
func log_error(msg) { print(C_RED, "[FAIL] ", C_RESET, msg); sys.exit(1); }

// ============================================================
//  LOGIQUE D'INSTALLATION (cmd: install)
// ============================================================

func install_package(pkg_name) {
    // 1. V√©rifier dossier modules
    io.exists(MODULES_DIR, "has_mod");
    if (has_mod == "no") { io.mkdir(MODULES_DIR); }

    print(C_BOLD, "üì¶ Traitement du paquet : ", pkg_name, C_RESET);

    // 2. Info API
    var info_url = REGISTRY_URL + "/api/package/info/global/" + pkg_name;
    var json_resp = http.get(info_url);
    
    if (json_resp == null) {
        log_error("Paquet introuvable ou erreur r√©seau.");
        return;
    }

    // 3. Parser
    var dl_path = json.get(json_resp, "download_url");
    var version = json.get(json_resp, "latest_version");

    if (dl_path == null) { log_error("Donn√©es invalides."); return; }

    print("   ‚ÑπÔ∏è  Version : ", version);

    // 4. Download
    var full_url = REGISTRY_URL + dl_path;
    var target_file = MODULES_DIR + "/" + pkg_name + ".tar.gz";
    var target_dir = MODULES_DIR + "/" + pkg_name;

    print("‚¨áÔ∏è  T√©l√©chargement...");
    var res = http.download(full_url, target_file);

    if (res == "success") {
        print(""); // Saut de ligne
        
        // 5. Extraction
        io.exists(target_dir, "has_target");
        if (has_target == "no") { io.mkdir(target_dir); }

        var cmd_untar = "tar -xzf " + target_file + " -C " + target_dir;
        sys.exec(cmd_untar);
        sys.exec("rm " + target_file);

        log_success("Install√© : " + pkg_name);
    } else {
        log_error("√âchec t√©l√©chargement.");
    }
}

// ============================================================
//  LOGIQUE DE LINK SYSTEME (cmd: link)
// ============================================================

func cmd_link_bin() {
    // 1. V√©rifier zarch.json
    io.exists("zarch.json", "has_conf");
    
    if (has_conf == "no") {
        log_error("Aucun fichier zarch.json trouv√©. √ätes-vous √† la racine du projet ?");
        return;
    }
    
    // 2. Lire config
    io.read("zarch.json", "content");
    
    var entry = json.get(content, "main");
    var alias = json.get(content, "alias");
    var name = json.get(content, "name");
    
    if (entry == null) {
        log_error("Pas de cl√© 'main' dans zarch.json");
        return;
    }
    
    // Si pas d'alias, on prend le nom du projet
    if (alias == null) {
        alias = name;
    }
    
    if (alias == null) {
        log_error("Impossible de d√©terminer le nom de l'alias (nom ou alias manquant)");
        return;
    }

    var source_file = "./" + entry;
    
    // 3. Rendre ex√©cutable (+x)
    print("üîß  Permission d'ex√©cution sur : ", source_file);
    var cmd_chmod = "chmod +x " + source_file;
    sys.exec(cmd_chmod);
    
    // 4. Cr√©er le lien symbolique syst√®me
    // Utilise $(pwd) pour avoir le chemin absolu actuel
    var target_link = INSTALL_PATH + "/" + alias;
    
    print("üîó  Lien syst√®me : ", target_link, " -> ", source_file);
    
    // Note: On utilise le shell pour r√©soudre $(pwd)
    var cmd_link = "ln -sf $(pwd)/" + entry + " " + target_link;
    var res = sys.exec(cmd_link);
    
    if (res == 0) {
        print("");
        log_success("Commande '" + alias + "' install√©e avec succ√®s !");
        print(C_BOLD, "    Tapez simplement : ", alias, C_RESET);
    } else {
        log_error("Permission refus√©e. Essayez avec 'sudo'.");
    }
}

// ============================================================
//  LOGIQUE INIT (cmd: init)
// ============================================================

func do_init() {
    io.exists("zarch.json", "has_conf");
    if (has_conf == "yes") {
        log_warn("D√©j√† initialis√©.");
        return;
    }
    
    var name = weld("Nom du projet: ");
    var entry = "main.swf";
    
    // Construction JSON manuelle
    var c = "{\n";
    c = c + '  "name": "' + name + '",\n';
    c = c + '  "version": "1.0.0",\n';
    c = c + '  "main": "' + entry + '",\n';
    c = c + '  "alias": "' + name + '"\n';
    c = c + "}";
    
    io.write("zarch.json", c);
    
    // Cr√©er un main.swf par d√©faut
    var code = '#!/usr/bin/env swift\n\nmain() {\n    print("Hello from ' + name + '!");\n}';
    io.write(entry, code);
    
    log_success("Projet initialis√© !");
}

// ============================================================
//  MAIN
// ============================================================

main() {
    var cmd = sys.argv(0);
    
    if (cmd == "link") {
        cmd_link_bin();
    }
    else if (cmd == "install") {
        var pkg = sys.argv(1);
        if (pkg != null) {
            install_package(pkg);
        } else {
            log_error("Nom du paquet manquant.");
        }
    }
    else if (cmd == "init") {
        do_init();
    }
    else {
        print("Usage: zarch [init|install|link]");
    }
}
