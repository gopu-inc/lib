// ============================================================
//  ZARCH - SwiftFlow Package Manager v1.0
//  (c) 2026 Gopu Inc.
// ============================================================

import "http";
import "sys";
import "io";
import "json";

// --- CONFIGURATION ---
var REGISTRY_URL = "https://zenv-hub.onrender.com";
var MODULES_DIR = "./zarch_modules";
var LOCK_FILE = "zarch.lock";

// --- COULEURS ANSI ---
var C_RESET = "\033[0m";
var C_BOLD = "\033[1m";
var C_CYAN = "\033[36m";
var C_GREEN = "\033[32m";
var C_YELLOW = "\033[33m";
var C_RED = "\033[31m";
var C_BLUE = "\033[34m";

// ============================================================
//  FONCTIONS UTILITAIRES
// ============================================================

func log_info(msg) {
    print(C_CYAN, "[INFO] ", C_RESET, msg);
}

func log_success(msg) {
    print(C_GREEN, "[OK]   ", C_RESET, msg);
}

func log_warn(msg) {
    print(C_YELLOW, "[WARN] ", C_RESET, msg);
}

func log_error(msg) {
    print(C_RED, "[FAIL] ", C_RESET, msg);
    sys.exit(1);
}

func log_header() {
    print(C_BLUE, "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó", C_RESET);
    print(C_BLUE, "‚ïë           ZARCH PACKAGE MANAGER            ‚ïë", C_RESET);
    print(C_BLUE, "‚ïë           v1.0.0 - SwiftFlow               ‚ïë", C_RESET);
    print(C_BLUE, "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù", C_RESET);
    print("");
}

// Simule une barre de chargement pour les op√©rations locales (extraction, link)
func fake_loading(label) {
    var width = 20;
    print(label);
    // Note: SwiftFlow n'a pas encore de sleep(), donc c'est instantan√©
    // mais on affiche la barre compl√®te pour le style
    print(C_GREEN, "[====================] 100%", C_RESET);
}

// ============================================================
//  LOGIQUE D'INSTALLATION
// ============================================================

func install_package(pkg_name) {
    // 1. V√©rifier/Cr√©er le dossier modules
    if (io.exists(MODULES_DIR) == false) {
        io.mkdir(MODULES_DIR);
    }

    print(C_BOLD, "üì¶ Traitement du paquet : ", pkg_name, C_RESET);

    // 2. Interroger l'API (R√©cup√©ration des m√©tadonn√©es)
    var info_url = REGISTRY_URL + "/api/package/info/global/" + pkg_name;
    log_info("Recherche des m√©tadonn√©es...");
    
    var json_resp = http.get(info_url);
    
    if (json_resp == null) {
        // Essayer le scope user si global √©choue (ex: @gopu/math)
        // Pour l'instant on g√®re le global simple
        log_error("Paquet introuvable ou erreur r√©seau.");
        return;
    }

    // 3. Parser la r√©ponse
    var version = json.get(json_resp, "latest_version");
    var dl_path = json.get(json_resp, "download_url");
    var desc = json.get(json_resp, "description");

    if (dl_path == null) {
        log_error("Donn√©es du paquet invalides.");
        return;
    }

    print("   ‚ÑπÔ∏è  Version : ", C_GREEN, version, C_RESET);
    print("   ‚ÑπÔ∏è  Desc    : ", desc);

    // 4. T√©l√©chargement
    var full_url = REGISTRY_URL + dl_path;
    var target_file = MODULES_DIR + "/" + pkg_name + ".tar.gz";
    var target_dir = MODULES_DIR + "/" + pkg_name;

    print(""); 
    log_info("D√©marrage du t√©l√©chargement...");
    
    // http.download affiche sa propre barre de progression en C
    var dl_result = http.download(full_url, target_file);

    if (dl_result == "success") {
        print(""); // Saut de ligne apr√®s la barre C
        log_success("T√©l√©chargement termin√©.");

        // 5. Extraction
        fake_loading("üìÇ Extraction de l'archive...");
        
        // Cr√©er le dossier cible
        if (io.exists(target_dir) == false) {
            io.mkdir(target_dir);
        }

        // Commande syst√®me tar
        var cmd_untar = "tar -xzf " + target_file + " -C " + target_dir;
        var res = sys.exec(cmd_untar);

        // 6. Nettoyage
        sys.exec("rm " + target_file);

        // 7. V√©rification Entrypoint (post-install)
        check_entrypoint(target_dir, pkg_name);

        log_success("Paquet install√© : " + pkg_name);
    } else {
        log_error("√âchec du t√©l√©chargement.");
    }
}

// V√©rifie si le paquet a un zarch.json et cr√©e un alias si n√©cessaire
func check_entrypoint(dir, pkg_name) {
    var manifest_path = dir + "/zarch.json";
    
    if (io.exists(manifest_path)) {
        var content = io.read(manifest_path);
        // Chercher "main" ou "activate" (parsing JSON basique)
        var main_file = json.get(content, "main");
        
        if (main_file != null) {
            log_info("Configuration de l'alias pour : " + main_file);
            
            // Cr√©er un lien symbolique √† la racine du projet
            // ex: ln -s zarch_modules/math/lib.swf math.swf
            var source = dir + "/" + main_file;
            var link_name = pkg_name + ".swf";
            
            var cmd_link = "ln -sf " + source + " " + link_name;
            sys.exec(cmd_link);
            
            print(C_CYAN, "   üîó Alias cr√©√© : ./", link_name, " -> ", source, C_RESET);
        }
    }
}

// ============================================================
//  COMMANDE LINK (Manuelle)
// ============================================================

func do_link(target, alias) {
    if (alias == null) {
        log_error("Alias manquant. Usage: zarch link <target> <alias>");
        return;
    }
    
    var cmd = "ln -sf " + target + " " + alias;
    sys.exec(cmd);
    log_success("Lien cr√©√© : " + alias + " -> " + target);
}

// ============================================================
//  COMMANDE INIT
// ============================================================

func do_init() {
    if (io.exists("zarch.json")) {
        log_warn("Un fichier zarch.json existe d√©j√†.");
        return;
    }
    
    var name = weld("Nom du projet: ");
    var version = "1.0.0";
    var main = "main.swf";
    
    // Cr√©ation manuelle du JSON (SwiftFlow n'a pas encore de json.stringify)
    var content = "{\n";
    content = content + '  "name": "' + name + '",\n';
    content = content + '  "version": "' + version + '",\n';
    content = content + '  "main": "' + main + '"\n';
    content = content + "}";
    
    io.write("zarch.json", content);
    log_success("Projet initialis√©. Fichier zarch.json cr√©√©.");
}

// ============================================================
//  MAIN
// ============================================================

main() {
    // R√©cup√©rer les arguments
    // sys.argv(0) est la commande (install, init, etc)
    var cmd = sys.argv(0);
    
    if (cmd == null) {
        log_header();
        print("Usage: swift zarch.swf <commande> [args]");
        print("");
        print("Commandes:");
        print("  install <package>   T√©l√©charger et installer un paquet");
        print("  init                Initialiser un nouveau projet");
        print("  link <src> <dest>   Cr√©er un lien symbolique manuellement");
        print("  help                Afficher cette aide");
        return;
    }

    if (cmd == "install") {
        var pkg = sys.argv(1);
        if (pkg != null) {
            install_package(pkg);
        } else {
            // TODO: Si pas d'arg, lire zarch.json et tout installer
            log_error("Veuillez sp√©cifier un paquet.");
        }
    }
    elif (cmd == "init") {
        do_init();
    }
    elif (cmd == "link") {
        do_link(sys.argv(1), sys.argv(2));
    }
    elif (cmd == "help") {
        log_header();
    }
    else {
        log_error("Commande inconnue : " + cmd);
    }
}
